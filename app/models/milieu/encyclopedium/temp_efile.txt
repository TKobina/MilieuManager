class XXEfile < ApplicationRecord
  belongs_to :encyclopedium
  belongs_to :efolder
  has_many :events, dependent: :destroy
  after_create_commit :parse_file
      # filename is a YDATE, for events
      # ## TITLE/HEADING
      # ```
      # proc | event | public/private
      # ```
      # details
      # ~ private details ~`

  def parse_file
    filetext = File.read(File.join(self.path, self.name))
    p filetext if self.name=="Nä'drë'e-3.md"
    
    #Break up sections by Headings and EOL
    positions_h, positions_l = get_header_indices(filetext)
    positions_h.each do |h_0|
      h_1 = positions_h.select { |element| element > h_0 }.first || filetext.length
      t = positions_l.select { |element| element > h_0 }.first || filetext.length

      @heading = filetext[h_0..t].remove("#").strip()
      text = filetext[t..h_1].remove("#").strip()
      i, j  = get_code_indices(text)
      if !i.nil?
        @text = text[j+3..].strip()
        parse_code(text[i+3..j-1].strip())
      end
    end
  end

  def parse_code(code)
    blocks = code.split("\n")
    p blocks if self.name=="Nä'drë'e-3.md"
    instruction = blocks[0].split("|").map{ |x| x.strip() }

    return unless instruction[0] == "proc"
    public = instruction[2] == "public"
    
    case instruction[1]
    when "event" then parse_event(blocks[1..].join("\n"), public)
    when "entity" then parse_entity(blocks: blocks[1..].join("\n"), public: public)
    else parse_block(blocks[1..].join("\n"))
    end
  end

  def parse_block(line)
    p "-----Instruction kind not handled by Efile:------" 
    p line
  end
  def parse_event(blocks, public)
    kinds = []
    blocks.split("\n").map{|x| kinds << x.split("|").map{|y| y.strip()}[0] }
    event = Event.new(kind: kinds.join(","), code: blocks, name: @heading, public: public, efile: self)
    event.milieu = self.encyclopedium.milieu
    event.ydate = event.milieu.get_date_from_strdate(self.name)
    event.details, event.private_details = parse_text
    event.save!
  end

  def parse_entity(blocks: "", public: false, entity: false)
    if !entity
      p blocks
      Rails.cache.write(self.name + ".public", public)
      Rails.cache.write(self.name, blocks)
    else
      binding.pry
      public = Rails.cache.read(self.name + ".public")
      blocks = Rails.cache.read(self.name)
      p "should this be nill?"
      p public
      p blocks
    end
  end

  def parse_text
    i, j  = @text.enum_for(:scan, /~/m).map { Regexp.last_match.begin(0) }
    public = j.nil? ? "" : @text[i+1..j-1].strip()
    private = i.nil? ? @text : @text[0..i-1].strip()
    return [public,private]
  end

  def fetch_details(entity)
    fname = entity.name + "-" + entity.eid + ".md"
    efile = self.encyclopedium.efiles.where(name: fname).first
    efile.parse_entity(entity: entity) if efile
  end

  private

  def get_header_indices(text)
    #Look for headers in files: lines that start with #
    positions_h = text.enum_for(:scan, /^(?:#)(.*)$/).map { Regexp.last_match.begin(0) }
    positions_l = text.enum_for(:scan, /\R/).map { Regexp.last_match.begin(0) }
    return [positions_h, positions_l]
  end

  def get_code_indices(text)
    #look for code blocks in files: blocks between ``` and ```
    i, j = text.enum_for(:scan, /```/m).map { Regexp.last_match.begin(0) }
    return [i, j]
  end

  
end
